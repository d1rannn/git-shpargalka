# Краткая шпаргалка для работы с GitBash (в основе бесплатного курса Yandex.Practicum)

### Написал d1rannn и специально для d1rannn 

Краткая шпаргалка для использования кодов Bash чтобы когда забыл посмотреть и сразу же вспомнить как и каким очередностем вводить команды. В общем полезно кратко и ясно. 
В кратце пройдемся что такое Git и почему это надо?

> Git (произносится «гит»[7]) — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

Среди проектов, использующих Git, — ядро Linux, Swift, Android, Drupal, Cairo, GNU Core Utilities, Mesa, Wine, Chromium, Compiz Fusion, FlightGear, jQuery, PHP, NASM, MediaWiki, DokuWiki, Qt, ряд дистрибутивов Linux.

Программа является свободной и выпущена под лицензией GNU GPL версии 2. По умолчанию используется TCP порт 9418.

Вот так и пишет [Википедия](https://ru.wikipedia.org/wiki/Git)

Но, если говоря по проще, Git это система управления версиями. Ты можешь с помощью гит управлять, всяческий манипулировать версиями какого-то иного проекта, просматривать кто, когда сделал изменения и отслеживать ветки версий проекта. Гит особенно хорош при работе с командами, но это не значит то, что ты не можешь урпавлять не работая в команде. Гит также тебе дает возможность работать над своим проектом и также отслеживать версий. Коротко говоря Гит дает тебе очень большые возможности при работе с версиями. ЖЖ

Давайте перейдем какие команды есть в GitBash:

 > `ls` -> Просмотр файлов репозитория

 > `ls ~` -> Просмотр скрытых файлов репозитория

 > `git init` -> Делает папку в репозиторий

 > `pwd` -> Показывает где ты находишься сейчас 

 > `cd (Путь к репозиторию)` -> Смена к репозиторию где ты хочешь быть

 > `rm -rf .git` -> Разгитить если все пошло хуево 

 > `git status`-> Статус репозитория

 > `touch (Название.расширение)` -> Создает файл 

А тут самое нужное. Это вплоть от создания файла + коммита репозитория и до загружения репозитория в ГитХаб.

 > `cd ~/dev`

 > `mkdir (Name of directory)`

 > `cd (Name of directory)`

 > `git init`

 > `touch README.md`

 > `git add README.md`

 > `git commit -m 'Добавить README'`

 > `git add remote origin (url)`

 > `git push -u origin master`

 > `git log` - Просмотр списков коммитов 

 > `git log --oneline` - Просмотр списков коммитов, но кратко 

	#### Статусы в Git

 В Git есть несколько состояния статусов: 

> untracked / tracked - неотслеживаемый / отслеживаемый 

> modified - измененный  
 
> staged - подготовленный 

> Если кратко, то каждый коммиченный файл сначало становиться неотслеживаемым, после как мы пишем команду `git add` то оно становиться неотслеживаемо-подготовленным, а если соответственно изменить файл, то после просмотра через `git log` оно будет измененным в зависимости что вы делали. 
Как вы заметили статусы могут быть парами, то есть (modified + staged, untracked + modified)  и так далее. 


	#### HEAD - это голова! А Commit всему голова! 

 Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый). 

 `HEAD` — это файл в .git, в файле — ссылка, по ссылке — хеш. Совсем как в сказке: иголка — в яйце, яйцо — в утке, утка — в зайце.
 
 `HEAD` указывает на последний коммит. Если передать его в качестве параметра, Git поймёт вас.

	#### Откат к прежней версий 

 > Команда `git restore --staged <file>` переведёт файл из staged обратно в modified или untracked.

 > Команда `git reset --hard <commit hash>` «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!

 > Команда `git restore <file>` «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.


	#### Исправление Коммитов
 
 > `--amend` рассчитан на работу с последним коммитом (HEAD).

 > Дополнить коммит новыми файлами можно с помощью `git commit --amend --no-edit`. Благодаря опции `--no-edit` сообщение к коммиту останется таким, каким и было.

 > Изменить сообщение к коммиту позволяет команда `git commit --amend -m "Обновлённое сообщение коммита"`


	#### Просмотр разниц файлов в GitBash 

 > Команда `git diff` сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.

 > Команда `git diff --staged` покажет изменения в staged-файлах относительно последних закоммиченных версий.


	#### Сравнение коммитов
 
 > Команда `git diff`! Эта команда поможет узнать, какие строки и в каких файлах изменились. Может быть полезно при поиске ошибок или чтобы разобраться, откуда появилась та или иная строка. В этом уроке вы также познакомились с командой `git diff <коммит1> <коммит2>`. С её помощью удобно сравнивать изменения в двух коммитах.

	#### Локальное копирование проекта

 > Команда `git clone` копирует проект на локальный компьютер.

 > `git clone` автоматически связывает локальный репозиторий с удалённым.

	#### Ветки
 
 > Ветка — это последовательность независимых изменений.

 > Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.

 > Основная версия проекта хранится в главной ветке main (или master).

 > С помощью команды `git branch` можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.

 > С помощью команды `git branch <название_ветки>` можно создавать ветки.

 > Команда `git checkout <название_ветки>` позволяет переключаться на другую ветку.

 > Разные ветки в одном проекте существуют независимо. Изменения в одной не влияют на изменения в другой.

 > В Git можно создать ветку и сразу же перейти в неё командой `git checkout -b <название_ветки>`.

 > Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

 > `git diff` может сравнивать ветки по их названиям. Например, команда `git diff main feature/my-feature` выведет разницу между основной веткой и веткой `feature/my-feature`.

 > Git поддерживает суффикс навигации ~. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить `git diff main~3 main`.

 > Выполнить слияние веток позволяет команда `git merge <название_ветки>`. В качестве параметра указывают название ветки, которую нужно влить в текущую.
 
 > Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда `git branch -D <название_ветки>` и её щадящий вариант с флагом `-d`.

	#### Pull-request

 > Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.

 > Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.

 > После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.

 > По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.

	#### git pull

 > Команда `git pull` позволяет подтянуть изменения из удалённого репозитория в локальный.

 > Перед созданием нового пул-реквеста считается хорошей практикой перейти в главную ветку, «подтянуть» в неё изменения, а затем добавить эти изменения в вашу ветку с помощью `git merge main`.

	#### Состояние fast-forward

 > Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:
 
  > * при слиянии этих двух веток никак не возможен конфликт;
  > * истории этих двух веток не «разошлись»;
  > * одна ветка является продолжением другой.
 
 > Хотя все эти условия звучат по-разному, они значат одно и то же. 

	#### Можно ли отключить fast-forward
 > Fast-forward слияние веток можно отключить флагом `--no-ff`. Например: `git merge --no-ff add-docs`. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») с помощью настройки merge.ff: `git config [--global] merge.ff false`.
 
 > Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния (англ. merge commit) — в обиходе его называют merge-коммит или мёрж-коммит. В этом случае результат «вливания» ветки add-docs в main выглядел бы так.

	#### Fast-forward & Non-fast-forward
 > Есть некоторые отличия между **Fast-forward & Non-fast-forward**. Давайте разберем что-да как. 

 > При **Fast-forward** —— 1. Конфликты при слиянии невозможны. 2. При слиянии веток по умолчанию не будет мёрж-коммита. 3. Истории двух веток можно выстроить в одну линию и, их коммиты никак не пересекутся. 

 > При **Non-fast-forward** –– 1. При слиянии веток обязательно будет мёрж-коммит. 2. Конфликт слияния возможен. 3. Истории двух веток нельзя выстроить в одну цепочку друг за другом. 

	#### Git push & Fast-forward
 > Если в локальном репозитории main сделать слияния коммитов, то после использование команды `git push` в репозитории на GitHub получит те же изменение которые были на локальном репозитории. Например представим это схематический: 

      ––*–––*–––*–––*–––>             –––––––*––––––––*–––––>
        C1  C2  C3  C4                       C1       C2

        Локальный Main                      main в GitHub

                               |
                               |
                               | 
                               ↓
   				  `git push`

              		      |
                               |
                               | 
                               ↓

      ––*–––*–––*–––*–––>             ––*–––*–––*–––*–––>
        C1  C2  C3  C4                  C1  C2  C3  C4

        Локальный Main                      main в GitHub

 > Команда `git push` выполняется успешно, только если `branch` и `branch@origin` находятся в состоянии `fast-forward`.
Эта команда ожидает, что обновление ветки будет происходить в режиме `fast-forward`.

 > С помощью перебазирования ветки возможно добиться состояния fast-forward, даже если раньше было не-fast-forward. Эта операция называется `rebase`.

 > Использование команды `git push --force` может привести к потере коммитов. Именно поэтому применение флага `--force` в большинстве случаев считается дурным тоном.

	#### О feature branch workflow коротко
 > Основные правила:
 - новая функциональность или исправление — новая ветка;
 - когда код в feature-ветке готов, он вливается в main;
 - в main всегда рабочая версия без «недоделок».
 > Преимущества:
 - простая модель;
 - позволяет работать с Git в команде без лишних технических сложностей.

 	> Шаблон, а не алгоритм
 > Подход feature branch workflow — это только «заготовка», которой необязательно следовать строго. Каждая команда подстраивает процесс под себя: например, что-то добавляет в модель или убирает из неё.
Так что описать все существующие возможности подхода было бы сложно. Важно запомнить его ключевую особенность: одна ветка main и много feature-веток, которые вливают в основную.

 - Разные компании и команды используют разные модели работы с Git. Эти модели описывают структуру веток в проекте, а также правила создания и слияния коммитов в них.
 - Один из самых простых и популярных подходов — `feature branch workflow`. Он предполагает, что работа над функциональностью ведётся в отдельной feature-ветке. Когда всё готово, эта ветка вливается в основную.
 - Подход `feature branch workflow` — лишь шаблон, по которому можно действовать. Многие компании и команды меняют его под свои нужды, но неизменно одно: хочешь сделать новую функциональность или исправить баг — создай новую ветку!

	#### Разрешение конфликта вручную и через vimdiff

 > Конфликты между измененными файлами и так далее могут быть множества, но мы разберем такой вариант событий где есть основная ветка main и позже созданные две ветки br1 и br2. В каждом ветке хранится измененный файл readme.md. Сначала для осуществления конфликта между ветками мёржим ветки main и br1, после мёржим ветки main и br2(мы помним то, что после мержа веток main и br1, все изменение в ветке br1 теперь находиться в главной ветке, но так как мы в обеих ветках хотим мержать две ветки в которых коммичены изменение одного и того же файла). Вот так вот мы делаем конфликт.
 
 > 1. *Мы можем решить этот конфликт вручную.* Для этого надо открыть наш файл и изменить его, после закомитить наши изменение и потом мержать наши ветки.

 > 2. *Или же мы можем решить конфликт через инструмент слияния `vmdiff`.*
Разрешение конфликтов вручную — долгий и трудоёмкий процесс. Чтобы упростить эту задачу, можно использовать инструменты слияния (англ. mergetool).
В ходе курса вы наверняка не раз сталкивались с редактором Vim в консоли. Он также предоставляет инструмент слияния, который называется `vimdiff`. Чтобы его вызвать, при возникновении конфликта нужно выполнить команду `git mergetool`.

	####

 > В командной работе регулярно случаются конфликты — и в этом нет ничего страшного.
 > Чтобы разрешить конфликт слияния, который возникает, когда главная ветка «уходит» вперёд, можно сделать следующее. Сначала локально получить новые изменения через `git pull`, а затем выполнить `git merge` и разрешить конфликт. Далее создать коммит слияния и отправить новые изменения без конфликтов обратно в удалённый репозиторий командой `git push`.
